"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = __importDefault(require("express"));
const commands_1 = __importDefault(require("./commands"));
const sessions_1 = require("./sessions");
const context_1 = __importDefault(require("./context"));
const imagesApi_1 = __importDefault(require("./imagesApi"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const utils_1 = require("./utils");
const middlewares_1 = require("./middlewares");
const aliceStateMiddleware_1 = __importDefault(require("./middlewares/aliceStateMiddleware"));
const eventEmitter_1 = __importDefault(require("./eventEmitter"));
const constants_1 = require("./constants");
const DEFAULT_SESSIONS_LIMIT = 1000;
const DEFAULT_TIMEOUT_CALLBACK_MESSAGE = 'Извините, но я не успела найти ответ за отведенное время.';
const DEFAULT_RESPONSE_TIMEOUT = 1200;
class Alice {
    constructor(config = {}) {
        this.anyCallback = null;
        this.welcomeCallback = null;
        this.commands = new commands_1.default(config.fuseOptions || null);
        this.middlewares = [aliceStateMiddleware_1.default()];
        this.scenes = [];
        this.currentScene = null;
        this.sessions = new sessions_1.Sessions();
        this.config = config;
        this.imagesApi = new imagesApi_1.default({
            oAuthToken: this.config.oAuthToken,
            skillId: this.config.skillId,
        });
        this.timeoutCallback = async (ctx) => ctx.reply(DEFAULT_TIMEOUT_CALLBACK_MESSAGE);
        this._handleEnterScene = this._handleEnterScene.bind(this);
        this._handleLeaveScene = this._handleLeaveScene.bind(this);
    }
    /* @TODO: Implement watchers (errors, messages) */
    // tslint:disable-next-line:no-empty
    on(event, callback) {
        eventEmitter_1.default.subscribe(event, callback);
    }
    /*
     * Attach alice middleware to the application
     * @param {Function} middleware - function, that receives {context}
     * and makes some modifications with it.
     */
    use(middleware) {
        if (!utils_1.isFunction(middleware)) {
            throw new Error('Any middleware could only be a function.');
        }
        this.middlewares.push(middleware);
    }
    /*
     * Set up the command
     * @param {string | Array<string> | regex} name — Trigger for the command
     * @param {Function} callback — Handler for the command
     */
    command(name, callback) {
        this.commands.add(name, callback);
    }
    /*
    * Стартовая команда на начало сессии
    */
    welcome(callback) {
        this.welcomeCallback = callback;
    }
    /*
     * Если среди команд не нашлось той,
     * которую запросил пользователь,
     * вызывается этот колбек
     */
    any(callback) {
        this.anyCallback = callback;
    }
    /*
     * Match the request with action handler,
     * compose and return a reply.
     * @param {Object} req — JSON request from the client
     * @param {Function} sendResponse — Express res function while listening on port.
     */
    async handleRequestBody(req, sendResponse) {
        /* clear old sessions */
        if (this.sessions.length > (this.config.sessionsLimit || DEFAULT_SESSIONS_LIMIT)) {
            this.sessions.flush();
        }
        /* initializing session */
        const sessionId = utils_1.selectSessionId(req);
        const session = this.sessions.findOrCreate(sessionId);
        /*
         * Initializing context of the request
         */
        const ctxDefaultParams = {
            req,
            session,
            sendResponse: sendResponse || null,
            /*
             * if Alice is listening on express.js port, add this server instance
             * to the context
             */
            server: this.server || null,
            middlewares: this.middlewares,
            eventEmitter: eventEmitter_1.default,
        };
        const ctxInstance = new context_1.default(ctxDefaultParams);
        const ctxWithMiddlewares = await middlewares_1.applyMiddlewares(this.middlewares, ctxInstance);
        eventEmitter_1.default.dispatch(constants_1.EVENT_MESSAGE_RECIEVED, {
            data: ctxWithMiddlewares.message, session: ctxWithMiddlewares.session,
        });
        /* check whether current scene is not defined */
        if (!session.getData('currentScene')) {
            session.setData('currentScene', null);
        }
        /* give control to the current scene */
        if (session.getData('currentScene') !== null) {
            const matchedScene = this.scenes.find((scene) => {
                return scene.name === session.getData('currentScene');
            });
            /*
             * Checking whether that's the leave scene
             * activation trigger
             */
            if (matchedScene) {
                if (await matchedScene.isLeaveCommand(ctxWithMiddlewares)) {
                    await matchedScene.handleRequest(req, sendResponse, ctxWithMiddlewares, 'leave');
                    session.setData('currentScene', null);
                    this._handleLeaveScene();
                    return true;
                }
                else {
                    const sceneResponse = await matchedScene.handleRequest(req, sendResponse, ctxWithMiddlewares);
                    if (sceneResponse) {
                        return true;
                    }
                }
            }
        }
        else {
            /*
             * Looking for scene's activational phrases
             */
            let matchedScene = null;
            for (const scene of this.scenes) {
                const result = await scene.isEnterCommand(ctxWithMiddlewares);
                if (result) {
                    matchedScene = scene;
                }
            }
            if (matchedScene) {
                session.setData('currentScene', matchedScene.name);
                this._handleEnterScene(matchedScene.name);
                const sceneResponse = await matchedScene.handleRequest(req, sendResponse, ctxWithMiddlewares, 'enter');
                if (sceneResponse) {
                    return true;
                }
            }
        }
        const requestedCommands = await this.commands.search(ctxWithMiddlewares);
        /*
        * Если новая сессия, то запускаем стартовую команду
        */
        if (req.session.new && this.welcomeCallback) {
            /*
             * Patch context with middlewares
             */
            if (this.welcomeCallback) {
                return await this.welcomeCallback(ctxWithMiddlewares);
            }
        }
        /*
         * Команда нашлась в списке.
         * Запускаем её обработчик.
         */
        if (requestedCommands.length !== 0) {
            const requestedCommand = requestedCommands[0];
            ctxWithMiddlewares.command = requestedCommand;
            return await requestedCommand.callback(ctxWithMiddlewares);
        }
        /*
         * Такой команды не было зарегестрировано.
         * Переходим в обработчик исключений
         */
        if (!this.anyCallback) {
            throw new Error([
                `alice.any(ctx => ctx.reply('404')) Method must be defined`,
                'to catch anything that not matches with commands',
            ].join('\n'));
        }
        return await this.anyCallback(ctxWithMiddlewares);
    }
    /*
     * Same as handleRequestBody, but syntax shorter
     */
    async handleRequest(req, sendResponse) {
        const executors = [
            /* proxy request to dev server, if enabled */
            this.config.devServerUrl
                ? await this.handleProxyRequest(req, this.config.devServerUrl, sendResponse)
                : await this.handleRequestBody(req, sendResponse),
            utils_1.rejectsIn(this.config.responseTimeout || DEFAULT_RESPONSE_TIMEOUT),
        ];
        return await Promise.race(executors)
            .then((result) => result)
            .catch(async (error) => {
            eventEmitter_1.default.dispatch(constants_1.EVENT_MESSAGE_NOT_SENT);
            this.timeoutCallback(new context_1.default({ req, sendResponse }));
        });
    }
    /*
     * Метод создаёт сервер, который слушает указанный порт.
  
     * Когда на указанный URL приходит POST запрос, управление
     * передаётся в @handleRequestBody
     *
     * При получении ответа от @handleRequestBody, результат
     * отправляется обратно.
     */
    async listen(webhookPath = '/', port = 80, callback) {
        return new Promise((resolve) => {
            const app = express_1.default();
            app.use(express_1.default.json());
            app.post(webhookPath, async (req, res) => {
                if (this.config.oAuthToken) {
                    res.setHeader('Authorization', this.config.oAuthToken);
                }
                res.setHeader('Content-type', 'application/json');
                let responseAlreadySent = false;
                const handleResponseCallback = (response) => {
                    /* dont answer twice */
                    if (responseAlreadySent) {
                        return false;
                    }
                    res.send(response);
                    responseAlreadySent = true;
                };
                try {
                    return await this.handleRequest(req.body, handleResponseCallback);
                }
                catch (error) {
                    throw new Error(error);
                }
            });
            this.server = app.listen(port, () => {
                // Resolves with callback function
                if (utils_1.isFunction(callback)) {
                    return callback.call(this);
                }
                // If no callback specified, resolves as a promise.
                return resolve();
                // Resolves with promise if no callback set
            });
        });
    }
    registerScene(scene) {
        // Allow for multiple scenes to be registered at once.
        if (Array.isArray(scene)) {
            scene.forEach((sceneItem) => this.scenes.push(sceneItem));
        }
        else {
            this.scenes.push(scene);
        }
    }
    async uploadImage(imageUrl) {
        return await this.imagesApi.uploadImage(imageUrl);
    }
    async getImages() {
        return await this.imagesApi.getImages();
    }
    stopListening() {
        if (this.server && this.server.close) {
            this.server.close();
        }
    }
    _handleEnterScene(sceneName) {
        this.currentScene = sceneName;
    }
    _handleLeaveScene() {
        this.currentScene = null;
    }
    async handleProxyRequest(request, devServerUrl, sendResponse) {
        try {
            const res = await node_fetch_1.default(devServerUrl, {
                method: 'POST',
                headers: { 'Content-type': 'application/json' },
                body: JSON.stringify(request),
            });
            const json = await res.json();
            return sendResponse(json);
        }
        catch (error) {
            console.error(error);
        }
    }
}
exports.default = Alice;
//# sourceMappingURL=alice.js.map