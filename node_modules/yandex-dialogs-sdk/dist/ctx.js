"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const { reversedInterpolation, selectCommand } = require('./utils');
const replyBuilder_1 = __importDefault(require("./replyBuilder"));
const buttonBuilder_1 = __importDefault(require("./buttonBuilder"));
const card_1 = require("./card");
const reply_1 = __importDefault(require("./reply"));
const eventEmitter_1 = __importDefault(require("./eventEmitter"));
const constants_1 = require("./constants");
class Ctx {
    constructor(params) {
        const { req, sendResponse, session, enterScene, leaveScene, command, } = params;
        this.req = req;
        this.sendResponse = sendResponse;
        this.sessionId = req.session.session_id;
        this.messageId = req.session.message_id;
        this.userId = req.session.user_id;
        this.payload = req.request.payload;
        this.message = req.request.command;
        this.session = session;
        this.eventEmitter = eventEmitter_1.default;
        this.replyBuilder = new replyBuilder_1.default(this.req);
        this.buttonBuilder = new buttonBuilder_1.default();
        if (enterScene && leaveScene) {
            this.enterScene = enterScene;
            this.leaveScene = leaveScene;
        }
        if (command) {
            this.command = command;
        }
    }
    get body() {
        const requestText = selectCommand(this.req);
        return reversedInterpolation(this.command.name, requestText);
    }
    async reply(replyMessage) {
        if (typeof replyMessage === 'undefined') {
            throw new Error('Reply message could not be empty!');
        }
        const message = this._createReply(replyMessage);
        eventEmitter_1.default.dispatch(constants_1.EVENT_MESSAGE_SENT, {
            data: message.response.text, session: this.req.session,
        });
        return this._sendReply(message);
    }
    async replyWithImage(params) {
        if (typeof params === 'string') {
            const message = this._createReply(reply_1.default(card_1.bigImageCard(card_1.image(params))));
            return this._sendReply(message);
        }
        else {
            const message = this._createReply(card_1.bigImageCard(params));
            return this._sendReply(message);
        }
    }
    async replyWithGallery() {
    }
    _createReply(replyMessage) {
        /*
        * Если @replyMessage — string,
        * то заворачиваем в стандартную форму.
        */
        if (typeof replyMessage === 'string') {
            replyMessage = this.replyBuilder
                .text(replyMessage)
                .tts(replyMessage)
                .get();
        }
        // Is no session, lets use context session
        if (!replyMessage.session) {
            replyMessage.session = this.session;
        }
        return replyMessage;
    }
    _sendReply(replyMessage) {
        /*
         * That fires when listening on port.
         */
        if (typeof this.sendResponse === 'function') {
            return this.sendResponse(replyMessage);
        }
        return replyMessage;
    }
}
exports.default = Ctx;
//# sourceMappingURL=ctx.js.map